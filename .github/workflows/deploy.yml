name: Deploy to AWS ECS

on:
  push:
    branches: [ main, dev, feature/docker-deployment, feat/frontend-clean ]

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: wherewego-app
  CONTAINER_NAME: wherewego-app

permissions:
  id-token: write
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/feature/docker-deployment' || github.ref == 'refs/heads/feat/frontend-clean'
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      environment: ${{ steps.set-env.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Notify build start
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV_ICON="🚀"
            ENV_NAME="Production"
          else
            ENV_ICON="🧪"
            ENV_NAME="Development"
          fi
          
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"#36a64f\",
              \"blocks\": [{
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"$ENV_ICON *WhereWeGo Build Started* 🔨\\n빌드를 시작합니다...\"
                }
              }, {
                \"type\": \"section\",
                \"fields\": [{
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Environment:*\\n$ENV_NAME\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Branch:*\\n\`${{ github.ref_name }}\`\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Commit:*\\n<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|\`$(echo ${{ github.sha }} | cut -c1-8)\`>\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Author:*\\n${{ github.actor }}\"
                }]
              }]
            }]
          }" ${{ secrets.SLACK_WEBHOOK }}

      - name: Set environment variables
        id: set-env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          else
            echo "environment=prod" >> $GITHUB_OUTPUT
          fi

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build Frontend
        run: |
          curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\": \"🎨 프론트엔드 빌드 중... (약 1-2분 소요)\"}" ${{ secrets.SLACK_WEBHOOK }}
          
          cd frontend
          npm ci
          npm run build
          cd ..

      - name: Build with Gradle
        run: |
          curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\": \"⚙️ Gradle 빌드 중... (약 1-2분 소요)\"}" ${{ secrets.SLACK_WEBHOOK }}
          
          ./gradlew clean build -x test

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Build
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          BUILD_START=$(date +%s)
          
          curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\": \"🐳 Docker 이미지 빌드 중... (약 2-3분 소요)\"}" ${{ secrets.SLACK_WEBHOOK }}
          
          # Docker 이미지 빌드 및 푸시
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
          # latest 태그도 푸시
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          BUILD_END=$(date +%s)
          BUILD_DURATION=$((BUILD_END - BUILD_START))
          
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"good\",
              \"blocks\": [{
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"🎉 *빌드 완료!* ✅\\n배포 준비가 완료되었습니다.\"
                }
              }, {
                \"type\": \"section\",
                \"fields\": [{
                  \"type\": \"mrkdwn\",
                  \"text\": \"*빌드 시간:*\\n⏱️ ${BUILD_DURATION}초\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*다음 단계:*\\n🚀 배포 시작 예정\"
                }]
              }]
            }]
          }" ${{ secrets.SLACK_WEBHOOK }}

  deploy:
    runs-on: ubuntu-latest
    needs: build
    outputs:
      cluster: ${{ steps.set-deploy-vars.outputs.cluster }}
      service: ${{ steps.set-deploy-vars.outputs.service }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js for deployment
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Set deployment variables
        id: set-deploy-vars
        run: |
          echo "cluster=wherewego-prod-cluster" >> $GITHUB_OUTPUT
          echo "service=wherewego-prod-service" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Notify deployment start
        run: |
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"#ff9500\",
              \"blocks\": [{
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"🚀 *배포 시작!* ⚡\\n새 버전을 서버에 배포 중...\"
                }
              }]
            }]
          }" ${{ secrets.SLACK_WEBHOOK }}

      - name: Deploy Frontend to S3
        run: |
          curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\": \"🎨 프론트엔드 배포 중... (S3 정적 웹사이트)\"}" ${{ secrets.SLACK_WEBHOOK }}

          # Get S3 bucket names from Parameter Store
          S3_BUCKET=$(aws ssm get-parameter --name "/wherewego/aws/s3/frontend-bucket" --query 'Parameter.Value' --output text)
          IMAGE_S3_BUCKET=$(aws ssm get-parameter --name "/wherewego/aws/s3/images-bucket" --query 'Parameter.Value' --output text)
          AWS_DEFAULT_REGION=$(aws ssm get-parameter --name "/wherewego/aws/region" --query 'Parameter.Value' --output text)
          
          echo "📦 Frontend S3 Bucket: $S3_BUCKET"
          echo "🖼️ Image S3 Bucket: $IMAGE_S3_BUCKET"
          
          # Build frontend with production environment variables
          cd frontend
          npm ci
          
          # Get ECS Task Public IP (after backend deployment)
          echo "🔍 ECS 서비스에서 Public IP 찾는 중..."
          ECS_PUBLIC_IP=$(aws ecs list-tasks \
            --cluster ${{ steps.set-deploy-vars.outputs.cluster }} \
            --service-name ${{ steps.set-deploy-vars.outputs.service }} \
            --query 'taskArns[0]' --output text | \
            xargs -I {} aws ecs describe-tasks \
            --cluster ${{ steps.set-deploy-vars.outputs.cluster }} \
            --tasks {} \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
            --output text | \
            xargs -I {} aws ec2 describe-network-interfaces \
            --network-interface-ids {} \
            --query 'NetworkInterfaces[0].Association.PublicIp' \
            --output text)
          
          echo "🌐 ECS Public IP: $ECS_PUBLIC_IP"
          
          # Get environment variables from Parameter Store
          KAKAO_CLIENT_ID=$(aws ssm get-parameter --name "/wherewego/kakao/client-id" --query 'Parameter.Value' --output text)
          GOOGLE_MAPS_API_KEY=$(aws ssm get-parameter --name "/wherewego/google/maps-api-key" --with-decryption --query 'Parameter.Value' --output text)
          GOOGLE_CLIENT_ID=$(aws ssm get-parameter --name "/wherewego/google/client-id" --query 'Parameter.Value' --output text)
          
          # Create production environment file
          cat > .env.production << EOF
          VITE_API_BASE_URL=http://${ECS_PUBLIC_IP}:8080
          VITE_IMAGE_BUCKET_URL=https://${IMAGE_S3_BUCKET}.s3.${AWS_DEFAULT_REGION}.amazonaws.com
          VITE_KAKAO_APP_KEY=${KAKAO_CLIENT_ID}
          VITE_KAKAO_MAP_KEY=${GOOGLE_MAPS_API_KEY}
          VITE_GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
          VITE_DEV_MODE=false
          VITE_LOG_LEVEL=warn
          EOF
          
          npm run build
          
          # Upload to S3 with proper website configuration
          aws s3 sync dist/ s3://$S3_BUCKET --delete
          
          # Enable S3 static website hosting
          aws s3 website s3://$S3_BUCKET --index-document index.html --error-document index.html
          
          cd ..
          
          curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\": \"✅ 프론트엔드 S3 배포 완료!\"}" ${{ secrets.SLACK_WEBHOOK }}

      - name: Update task definition and start deployment
        run: |
          DEPLOY_START=$(date +%s)
          
          # ECR URI를 태스크 정의에 반영
          sed "s|ECR_URI_PLACEHOLDER|${{ needs.build.outputs.image-uri }}|g" aws/task-definition.json > temp-task-definition.json
          
          # 태스크 정의 등록
          TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://temp-task-definition.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "✅ Task definition registered: $TASK_DEF_ARN"
          
          # 서비스 존재 여부 확인
          SERVICE_EXISTS=$(aws ecs describe-services --cluster ${{ steps.set-deploy-vars.outputs.cluster }} --services ${{ steps.set-deploy-vars.outputs.service }} --query 'length(services)' --output text 2>/dev/null || echo "0")
          
          if [[ "$SERVICE_EXISTS" == "0" ]]; then
            echo "🚀 Creating new ECS service..."
          
            # CloudFormation Outputs에서 리소스 ID 가져오기
            PUBLIC_SUBNET_1=$(aws cloudformation describe-stacks \
              --stack-name "wherewego-${{ needs.build.outputs.environment }}" \
              --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet1`].OutputValue' \
              --output text)
              
            PUBLIC_SUBNET_2=$(aws cloudformation describe-stacks \
              --stack-name "wherewego-${{ needs.build.outputs.environment }}" \
              --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet2`].OutputValue' \
              --output text)
              
            ECS_SECURITY_GROUP=$(aws cloudformation describe-stacks \
              --stack-name "wherewego-${{ needs.build.outputs.environment }}" \
              --query 'Stacks[0].Outputs[?OutputKey==`ECSSecurityGroup`].OutputValue' \
              --output text)
              
            ALB_TARGET_GROUP_ARN=$(aws cloudformation describe-stacks \
              --stack-name "wherewego-${{ needs.build.outputs.environment }}" \
              --query 'Stacks[0].Outputs[?OutputKey==`ALBTargetGroupArn`].OutputValue' \
              --output text)
            
            echo "📋 CloudFormation Stack: wherewego-${{ needs.build.outputs.environment }}"
            echo "🔗 Using subnets: $PUBLIC_SUBNET_1, $PUBLIC_SUBNET_2"
            echo "🛡️ Using security group: $ECS_SECURITY_GROUP"
            echo "🎯 Using target group: $ALB_TARGET_GROUP_ARN"
          
            # ECS 서비스 생성
            aws ecs create-service \
              --cluster ${{ steps.set-deploy-vars.outputs.cluster }} \
              --service-name ${{ steps.set-deploy-vars.outputs.service }} \
              --task-definition ${{ env.CONTAINER_NAME }} \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[$PUBLIC_SUBNET_1,$PUBLIC_SUBNET_2],securityGroups=[$ECS_SECURITY_GROUP],assignPublicIp=ENABLED}" \
              --load-balancers "targetGroupArn=$ALB_TARGET_GROUP_ARN,containerName=${{ env.CONTAINER_NAME }},containerPort=8080"
          else
            echo "🔄 Updating existing ECS service..."
          
            # 기존 서비스 업데이트
            aws ecs update-service \
              --cluster ${{ steps.set-deploy-vars.outputs.cluster }} \
              --service ${{ steps.set-deploy-vars.outputs.service }} \
              --task-definition ${{ env.CONTAINER_NAME }} \
              --desired-count 1
          fi
          
          DEPLOY_END=$(date +%s)
          DEPLOY_DURATION=$((DEPLOY_END - DEPLOY_START))
          
          # 임시 파일 정리
          rm temp-task-definition.json
          
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"#36a64f\",
              \"blocks\": [{
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"⚡ *배포 시작됨!* 🎯\\n서비스가 업데이트되었습니다.\"
                }
              }, {
                \"type\": \"section\",
                \"fields\": [{
                  \"type\": \"mrkdwn\",
                  \"text\": \"*배포 시간:*\\n⏱️ ${DEPLOY_DURATION}초\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*상태:*\\n🔄 헬스체크 진행 중\"
                }]
              }]
            }]
          }" ${{ secrets.SLACK_WEBHOOK }}

  verify:
    runs-on: ubuntu-latest
    needs: [build, deploy]
    if: always()
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Verify
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for service stability and final notification
        run: |
          VERIFY_START=$(date +%s)
          
          curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\": \"🏥 헬스체크 진행 중... (약 3-5분 소요)\"}" ${{ secrets.SLACK_WEBHOOK }}
          
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            # 서비스 안정화 대기
            echo "⏳ Waiting for service stability..."
            aws ecs wait services-stable \
              --cluster ${{ needs.deploy.outputs.cluster }} \
              --services ${{ needs.deploy.outputs.service }} \
              --cli-read-timeout 600 || echo "⚠️ 타임아웃이지만 서비스는 백그라운드에서 계속 진행됩니다"
          fi
          
          VERIFY_END=$(date +%s)
          VERIFY_DURATION=$((VERIFY_END - VERIFY_START))
          VERIFY_MIN=$((VERIFY_DURATION / 60))
          VERIFY_SEC=$((VERIFY_DURATION % 60))
          
          # 전체 결과에 따른 메시지 설정
          if [[ "${{ needs.build.result }}" == "success" && "${{ needs.deploy.result }}" == "success" ]]; then
            COLOR="good"
            STATUS="✅ SUCCESS"
            MESSAGE="배포가 성공적으로 완료되었습니다!"
            EMOJI="🎉"
          else
            COLOR="danger" 
            STATUS="❌ FAILED"
            if [[ "${{ needs.build.result }}" == "failure" ]]; then
              MESSAGE="빌드 중 오류가 발생했습니다."
            elif [[ "${{ needs.deploy.result }}" == "failure" ]]; then
              MESSAGE="배포 중 오류가 발생했습니다."
            else
              MESSAGE="알 수 없는 오류가 발생했습니다."
            fi
            EMOJI="💥"
          fi
          
          # 브랜치에 따른 환경 이모지
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV_ICON="🚀"
            ENV_NAME="Production"
          else
            ENV_ICON="🧪"
            ENV_NAME="Development"
          fi
          
          # 커밋 메시지 가져오기
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          COMMIT_MSG=$(echo "$COMMIT_MSG" | head -c 50)
          
          # 프론트엔드 URL 가져오기
          FRONTEND_URL=$(aws cloudformation describe-stacks \
            --stack-name "wherewego-${{ needs.build.outputs.environment }}" \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendURL`].OutputValue' \
            --output text 2>/dev/null || echo "설정 중...")
            
          # 백엔드 URL 가져오기 (ECS Public IP)  
          BACKEND_URL="http://ECS-Public-IP:8080 (동적 IP)"
          
          # 최종 Slack 메시지 전송
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"$COLOR\",
              \"blocks\": [{
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"$EMOJI $ENV_ICON *WhereWeGo Deployment* $STATUS\\n$MESSAGE\"
                }
              }, {
                \"type\": \"section\",
                \"fields\": [{
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Environment:*\\n$ENV_NAME\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Branch:*\\n\`${{ github.ref_name }}\`\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*헬스체크:*\\n⏱️ ${VERIFY_MIN}분 ${VERIFY_SEC}초\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Author:*\\n👤 ${{ github.actor }}\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Commit:*\\n<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|\`$(echo ${{ github.sha }} | cut -c1-8)\`>\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Message:*\\n💬 $COMMIT_MSG\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Frontend:*\\n🌐 $FRONTEND_URL\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Backend:*\\n⚙️ $BACKEND_URL\"
                }]
              }, {
                \"type\": \"actions\",
                \"elements\": [{
                  \"type\": \"button\",
                  \"text\": {
                    \"type\": \"plain_text\",
                    \"text\": \"🔍 View Workflow\"
                  },
                  \"url\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                }]
              }]
            }]
          }" ${{ secrets.SLACK_WEBHOOK }}