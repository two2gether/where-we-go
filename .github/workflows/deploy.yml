name: Deploy to AWS ECS

on:
  push:
    branches: [ main, dev, feature/docker-deployment ]

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: wherewego-app
  CONTAINER_NAME: wherewego-app

permissions:
  id-token: write
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/feature/docker-deployment'
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      environment: ${{ steps.set-env.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Notify build start
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV_ICON="üöÄ"
            ENV_NAME="Production"
          else
            ENV_ICON="üß™"
            ENV_NAME="Development"
          fi
          
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"#36a64f\",
              \"blocks\": [{
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"$ENV_ICON *WhereWeGo Build Started* üî®\\nÎπåÎìúÎ•º ÏãúÏûëÌï©ÎãàÎã§...\"
                }
              }, {
                \"type\": \"section\",
                \"fields\": [{
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Environment:*\\n$ENV_NAME\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Branch:*\\n\`${{ github.ref_name }}\`\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Commit:*\\n<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|\`$(echo ${{ github.sha }} | cut -c1-8)\`>\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Author:*\\n${{ github.actor }}\"
                }]
              }]
            }]
          }" ${{ secrets.SLACK_WEBHOOK }}

      - name: Set environment variables
        id: set-env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          else
            echo "environment=prod" >> $GITHUB_OUTPUT
          fi

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build Frontend
        run: |
          curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\": \"üé® ÌîÑÎ°†Ìä∏ÏóîÎìú ÎπåÎìú Ï§ë... (ÏïΩ 1-2Î∂Ñ ÏÜåÏöî)\"}" ${{ secrets.SLACK_WEBHOOK }}
          
          cd frontend
          npm ci
          npm run build
          cd ..

      - name: Build with Gradle
        run: |
          curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\": \"‚öôÔ∏è Gradle ÎπåÎìú Ï§ë... (ÏïΩ 1-2Î∂Ñ ÏÜåÏöî)\"}" ${{ secrets.SLACK_WEBHOOK }}
          
          ./gradlew clean build -x test

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Build
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          BUILD_START=$(date +%s)
          
          curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\": \"üê≥ Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú Ï§ë... (ÏïΩ 2-3Î∂Ñ ÏÜåÏöî)\"}" ${{ secrets.SLACK_WEBHOOK }}
          
          # Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú Î∞è Ìë∏Ïãú
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
          # latest ÌÉúÍ∑∏ÎèÑ Ìë∏Ïãú
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          BUILD_END=$(date +%s)
          BUILD_DURATION=$((BUILD_END - BUILD_START))
          
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"good\",
              \"blocks\": [{
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"üéâ *ÎπåÎìú ÏôÑÎ£å!* ‚úÖ\\nÎ∞∞Ìè¨ Ï§ÄÎπÑÍ∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.\"
                }
              }, {
                \"type\": \"section\",
                \"fields\": [{
                  \"type\": \"mrkdwn\",
                  \"text\": \"*ÎπåÎìú ÏãúÍ∞Ñ:*\\n‚è±Ô∏è ${BUILD_DURATION}Ï¥à\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Îã§Ïùå Îã®Í≥Ñ:*\\nüöÄ Î∞∞Ìè¨ ÏãúÏûë ÏòàÏ†ï\"
                }]
              }]
            }]
          }" ${{ secrets.SLACK_WEBHOOK }}

  deploy:
    runs-on: ubuntu-latest
    needs: build
    outputs:
      cluster: ${{ steps.set-deploy-vars.outputs.cluster }}
      service: ${{ steps.set-deploy-vars.outputs.service }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js for deployment
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Set deployment variables
        id: set-deploy-vars
        run: |
          echo "cluster=wherewego-prod-cluster" >> $GITHUB_OUTPUT
          echo "service=wherewego-prod-service" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Notify deployment start
        run: |
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"#ff9500\",
              \"blocks\": [{
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"üöÄ *Î∞∞Ìè¨ ÏãúÏûë!* ‚ö°\\nÏÉà Î≤ÑÏ†ÑÏùÑ ÏÑúÎ≤ÑÏóê Î∞∞Ìè¨ Ï§ë...\"
                }
              }]
            }]
          }" ${{ secrets.SLACK_WEBHOOK }}

      - name: Deploy Frontend to S3
        run: |
          curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\": \"üé® ÌîÑÎ°†Ìä∏ÏóîÎìú Î∞∞Ìè¨ Ï§ë... (S3 ÏóÖÎ°úÎìú)\"}" ${{ secrets.SLACK_WEBHOOK }}

          # Get S3 bucket name from CloudFormation
          S3_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name "wherewego-${{ needs.build.outputs.environment }}" \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendS3Bucket`].OutputValue' \
            --output text)
          
          echo "üì¶ S3 Bucket: $S3_BUCKET"
          
          # Build frontend with production environment variables
          cd frontend
          npm ci
          
          # Create production environment file
          cat > .env.production << EOF
          VITE_API_BASE_URL=${{ secrets.VITE_API_BASE_URL || 'https://api.wherewego.co.kr' }}
          VITE_KAKAO_APP_KEY=${{ secrets.VITE_KAKAO_APP_KEY }}
          VITE_KAKAO_MAP_KEY=${{ secrets.VITE_KAKAO_MAP_KEY }}
          VITE_GOOGLE_CLIENT_ID=${{ secrets.VITE_GOOGLE_CLIENT_ID }}
          VITE_DEV_MODE=false
          VITE_LOG_LEVEL=warn
          EOF
          
          npm run build
          
          # Upload to S3
          aws s3 sync dist/ s3://$S3_BUCKET --delete --cache-control "max-age=31536000"
          
          # Invalidate CloudFront cache
          CLOUDFRONT_DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
            --stack-name "wherewego-${{ needs.build.outputs.environment }}" \
            --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontDistributionId`].OutputValue' \
            --output text)
          
          echo "üåê CloudFront Distribution ID: $CLOUDFRONT_DISTRIBUTION_ID"
          
          aws cloudfront create-invalidation \
            --distribution-id $CLOUDFRONT_DISTRIBUTION_ID \
            --paths "/*"
          
          cd ..
          
          curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\": \"‚úÖ ÌîÑÎ°†Ìä∏ÏóîÎìú Î∞∞Ìè¨ ÏôÑÎ£å! CDN Ï∫êÏãú Î¨¥Ìö®Ìôî ÏßÑÌñâ Ï§ë...\"}" ${{ secrets.SLACK_WEBHOOK }}

      - name: Update task definition and start deployment
        run: |
          DEPLOY_START=$(date +%s)
          
          # ECR URIÎ•º ÌÉúÏä§ÌÅ¨ Ï†ïÏùòÏóê Î∞òÏòÅ
          sed "s|ECR_URI_PLACEHOLDER|${{ needs.build.outputs.image-uri }}|g" aws/task-definition.json > temp-task-definition.json
          
          # ÌÉúÏä§ÌÅ¨ Ï†ïÏùò Îì±Î°ù
          TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://temp-task-definition.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "‚úÖ Task definition registered: $TASK_DEF_ARN"
          
          # ÏÑúÎπÑÏä§ Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏
          SERVICE_EXISTS=$(aws ecs describe-services --cluster ${{ steps.set-deploy-vars.outputs.cluster }} --services ${{ steps.set-deploy-vars.outputs.service }} --query 'length(services)' --output text 2>/dev/null || echo "0")
          
          if [[ "$SERVICE_EXISTS" == "0" ]]; then
            echo "üöÄ Creating new ECS service..."
          
            # CloudFormation OutputsÏóêÏÑú Î¶¨ÏÜåÏä§ ID Í∞ÄÏ†∏Ïò§Í∏∞
            PUBLIC_SUBNET_1=$(aws cloudformation describe-stacks \
              --stack-name "wherewego-${{ needs.build.outputs.environment }}" \
              --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet1`].OutputValue' \
              --output text)
              
            PUBLIC_SUBNET_2=$(aws cloudformation describe-stacks \
              --stack-name "wherewego-${{ needs.build.outputs.environment }}" \
              --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet2`].OutputValue' \
              --output text)
              
            ECS_SECURITY_GROUP=$(aws cloudformation describe-stacks \
              --stack-name "wherewego-${{ needs.build.outputs.environment }}" \
              --query 'Stacks[0].Outputs[?OutputKey==`ECSSecurityGroup`].OutputValue' \
              --output text)
            
            echo "üìã CloudFormation Stack: wherewego-${{ needs.build.outputs.environment }}"
            echo "üîó Using subnets: $PUBLIC_SUBNET_1, $PUBLIC_SUBNET_2"
            echo "üõ°Ô∏è Using security group: $ECS_SECURITY_GROUP"
          
            # ECS ÏÑúÎπÑÏä§ ÏÉùÏÑ±
            aws ecs create-service \
              --cluster ${{ steps.set-deploy-vars.outputs.cluster }} \
              --service-name ${{ steps.set-deploy-vars.outputs.service }} \
              --task-definition ${{ env.CONTAINER_NAME }} \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[$PUBLIC_SUBNET_1,$PUBLIC_SUBNET_2],securityGroups=[$ECS_SECURITY_GROUP],assignPublicIp=ENABLED}"
          else
            echo "üîÑ Updating existing ECS service..."
          
            # Í∏∞Ï°¥ ÏÑúÎπÑÏä§ ÏóÖÎç∞Ïù¥Ìä∏
            aws ecs update-service \
              --cluster ${{ steps.set-deploy-vars.outputs.cluster }} \
              --service ${{ steps.set-deploy-vars.outputs.service }} \
              --task-definition ${{ env.CONTAINER_NAME }} \
              --desired-count 1
          fi
          
          DEPLOY_END=$(date +%s)
          DEPLOY_DURATION=$((DEPLOY_END - DEPLOY_START))
          
          # ÏûÑÏãú ÌååÏùº Ï†ïÎ¶¨
          rm temp-task-definition.json
          
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"#36a64f\",
              \"blocks\": [{
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"‚ö° *Î∞∞Ìè¨ ÏãúÏûëÎê®!* üéØ\\nÏÑúÎπÑÏä§Í∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.\"
                }
              }, {
                \"type\": \"section\",
                \"fields\": [{
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Î∞∞Ìè¨ ÏãúÍ∞Ñ:*\\n‚è±Ô∏è ${DEPLOY_DURATION}Ï¥à\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*ÏÉÅÌÉú:*\\nüîÑ Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏßÑÌñâ Ï§ë\"
                }]
              }]
            }]
          }" ${{ secrets.SLACK_WEBHOOK }}

  verify:
    runs-on: ubuntu-latest
    needs: [build, deploy]
    if: always()
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Verify
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for service stability and final notification
        run: |
          VERIFY_START=$(date +%s)
          
          curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\": \"üè• Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏßÑÌñâ Ï§ë... (ÏïΩ 3-5Î∂Ñ ÏÜåÏöî)\"}" ${{ secrets.SLACK_WEBHOOK }}
          
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            # ÏÑúÎπÑÏä§ ÏïàÏ†ïÌôî ÎåÄÍ∏∞
            echo "‚è≥ Waiting for service stability..."
            aws ecs wait services-stable \
              --cluster ${{ needs.deploy.outputs.cluster }} \
              --services ${{ needs.deploy.outputs.service }} \
              --cli-read-timeout 600 || echo "‚ö†Ô∏è ÌÉÄÏûÑÏïÑÏõÉÏù¥ÏßÄÎßå ÏÑúÎπÑÏä§Îäî Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Í≥ÑÏÜç ÏßÑÌñâÎê©ÎãàÎã§"
          fi
          
          VERIFY_END=$(date +%s)
          VERIFY_DURATION=$((VERIFY_END - VERIFY_START))
          VERIFY_MIN=$((VERIFY_DURATION / 60))
          VERIFY_SEC=$((VERIFY_DURATION % 60))
          
          # Ï†ÑÏ≤¥ Í≤∞Í≥ºÏóê Îî∞Î•∏ Î©îÏãúÏßÄ ÏÑ§Ï†ï
          if [[ "${{ needs.build.result }}" == "success" && "${{ needs.deploy.result }}" == "success" ]]; then
            COLOR="good"
            STATUS="‚úÖ SUCCESS"
            MESSAGE="Î∞∞Ìè¨Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!"
            EMOJI="üéâ"
          else
            COLOR="danger" 
            STATUS="‚ùå FAILED"
            if [[ "${{ needs.build.result }}" == "failure" ]]; then
              MESSAGE="ÎπåÎìú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
            elif [[ "${{ needs.deploy.result }}" == "failure" ]]; then
              MESSAGE="Î∞∞Ìè¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
            else
              MESSAGE="Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."
            fi
            EMOJI="üí•"
          fi
          
          # Î∏åÎûúÏπòÏóê Îî∞Î•∏ ÌôòÍ≤Ω Ïù¥Î™®ÏßÄ
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV_ICON="üöÄ"
            ENV_NAME="Production"
          else
            ENV_ICON="üß™"
            ENV_NAME="Development"
          fi
          
          # Ïª§Î∞ã Î©îÏãúÏßÄ Í∞ÄÏ†∏Ïò§Í∏∞
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          COMMIT_MSG=$(echo "$COMMIT_MSG" | head -c 50)
          
          # ÌîÑÎ°†Ìä∏ÏóîÎìú URL Í∞ÄÏ†∏Ïò§Í∏∞
          FRONTEND_URL=$(aws cloudformation describe-stacks \
            --stack-name "wherewego-${{ needs.build.outputs.environment }}" \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendURL`].OutputValue' \
            --output text 2>/dev/null || echo "ÏÑ§Ï†ï Ï§ë...")
          
          # ÏµúÏ¢Ö Slack Î©îÏãúÏßÄ Ï†ÑÏÜ°
          curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"$COLOR\",
              \"blocks\": [{
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"$EMOJI $ENV_ICON *WhereWeGo Deployment* $STATUS\\n$MESSAGE\"
                }
              }, {
                \"type\": \"section\",
                \"fields\": [{
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Environment:*\\n$ENV_NAME\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Branch:*\\n\`${{ github.ref_name }}\`\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Ìó¨Ïä§Ï≤¥ÌÅ¨:*\\n‚è±Ô∏è ${VERIFY_MIN}Î∂Ñ ${VERIFY_SEC}Ï¥à\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Author:*\\nüë§ ${{ github.actor }}\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Commit:*\\n<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|\`$(echo ${{ github.sha }} | cut -c1-8)\`>\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Message:*\\nüí¨ $COMMIT_MSG\"
                }, {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Frontend:*\\nüåê $FRONTEND_URL\"
                }]
              }, {
                \"type\": \"actions\",
                \"elements\": [{
                  \"type\": \"button\",
                  \"text\": {
                    \"type\": \"plain_text\",
                    \"text\": \"üîç View Workflow\"
                  },
                  \"url\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                }]
              }]
            }]
          }" ${{ secrets.SLACK_WEBHOOK }}