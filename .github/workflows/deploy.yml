name: Deploy to AWS ECS

on:
  push:
    branches: [main, dev, feature/docker-deployment]
  pull_request:
    branches: [main, dev]

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: wherewego-app
  CONTAINER_NAME: wherewego-app

permissions:
  id-token: write
  contents: read
  actions: read
  security-events: write
  checks: write
  pull-requests: write

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Grant execute permission for gradlew
      run: chmod +x gradlew

    - name: Run tests (skip for deployment)
      run: echo "Skipping tests for deployment" # ./gradlew test --no-daemon

    # - name: Generate test report
    #   uses: dorny/test-reporter@v1
    #   if: success() || failure()
    #   with:
    #     name: Gradle Tests
    #     path: build/test-results/test/*.xml
    #     reporter: java-junit
    #     fail-on-error: false

  security-scan:
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run security scan with Trivy
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'table'
        # format: 'sarif'
        # output: 'trivy-results.sarif'

    # - name: Upload Trivy scan results
    #   uses: github/codeql-action/upload-sarif@v3
    #   if: always()
    #   with:
    #     sarif_file: 'trivy-results.sarif'

  build-and-deploy:
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/feature/docker-deployment'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set environment variables
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "ENVIRONMENT=prod" >> $GITHUB_ENV
          echo "ECS_CLUSTER=wherewego-prod-cluster" >> $GITHUB_ENV
          echo "ECS_SERVICE=wherewego-prod-service" >> $GITHUB_ENV
        elif [[ "${{ github.ref }}" == "refs/heads/feature/docker-deployment" ]]; then
          echo "ENVIRONMENT=prod" >> $GITHUB_ENV
          echo "ECS_CLUSTER=wherewego-prod-cluster" >> $GITHUB_ENV
          echo "ECS_SERVICE=wherewego-prod-service" >> $GITHUB_ENV
        else
          echo "ENVIRONMENT=dev" >> $GITHUB_ENV
          echo "ECS_CLUSTER=wherewego-dev-cluster" >> $GITHUB_ENV
          echo "ECS_SERVICE=wherewego-dev-service" >> $GITHUB_ENV
        fi

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: GitHubActions
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Docker ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        
        # latest íƒœê·¸ë„ í‘¸ì‹œ
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Register task definition
      run: |
        echo "Registering task definition..."
        # ECR URIë¥¼ íƒœìŠ¤í¬ ì •ì˜ì— ë°˜ì˜
        sed "s|ECR_URI_PLACEHOLDER|${{ steps.login-ecr.outputs.registry }}/$ECR_REPOSITORY:${{ github.sha }}|g" aws/task-definition.json > temp-task-definition.json
        
        # íƒœìŠ¤í¬ ì •ì˜ ë“±ë¡
        TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://temp-task-definition.json --query 'taskDefinition.taskDefinitionArn' --output text)
        echo "Task definition registered: $TASK_DEF_ARN"
        
        # ë“±ë¡ëœ íƒœìŠ¤í¬ ì •ì˜ ë‹¤ìš´ë¡œë“œ (ìµœì‹  ë²„ì „ ì‚¬ìš©)
        aws ecs describe-task-definition --task-definition $TASK_DEF_ARN --query taskDefinition > task-definition.json
        
        # ì„ì‹œ íŒŒì¼ ì •ë¦¬
        rm temp-task-definition.json


    - name: Check if ECS service exists
      id: check-service
      run: |
        echo "Checking if ECS service exists..."
        
        # Check if service exists
        SERVICE_STATUS=$(aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].status' \
          --output text 2>/dev/null || echo "NONE")
        
        echo "Service status: $SERVICE_STATUS"
        
        if [[ "$SERVICE_STATUS" == "ACTIVE" ]]; then
          echo "service_exists=true" >> $GITHUB_OUTPUT
          echo "âœ… Service exists and is active"
        else
          echo "service_exists=false" >> $GITHUB_OUTPUT
          echo "âŒ Service does not exist or is not active"
        fi

    - name: Create ECS service if not exists
      if: steps.check-service.outputs.service_exists == 'false'
      run: |
        echo "Creating ECS service: ${{ env.ECS_SERVICE }}"
        
        # CloudFormation Outputì—ì„œ ë™ì ìœ¼ë¡œ ë¦¬ì†ŒìŠ¤ ID ì¡°íšŒ
        echo "Retrieving resource IDs from CloudFormation..."
        
        # CloudFormation Stackì—ì„œ ë¦¬ì†ŒìŠ¤ IDë“¤ì„ ë™ì ìœ¼ë¡œ ì¡°íšŒ
        PUBLIC_SUBNET_1=$(aws cloudformation describe-stacks \
          --stack-name wherewego-prod-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet1`].OutputValue' \
          --output text)
        
        PUBLIC_SUBNET_2=$(aws cloudformation describe-stacks \
          --stack-name wherewego-prod-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet2`].OutputValue' \
          --output text)
        
        ECS_SECURITY_GROUP=$(aws cloudformation describe-stacks \
          --stack-name wherewego-prod-infrastructure \
          --query 'Stacks[0].Outputs[?OutputKey==`ECSSecurityGroup`].OutputValue' \
          --output text)
        
        echo "Public Subnet 1: $PUBLIC_SUBNET_1"
        echo "Public Subnet 2: $PUBLIC_SUBNET_2" 
        echo "ECS Security Group: $ECS_SECURITY_GROUP"
        
        # ì¡°íšŒëœ ID ê²€ì¦
        if [[ -z "$PUBLIC_SUBNET_1" || -z "$PUBLIC_SUBNET_2" || -z "$ECS_SECURITY_GROUP" ]]; then
          echo "âŒ CloudFormationì—ì„œ ë¦¬ì†ŒìŠ¤ IDë¥¼ ì¡°íšŒí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤!"
          echo "PUBLIC_SUBNET_1: $PUBLIC_SUBNET_1"
          echo "PUBLIC_SUBNET_2: $PUBLIC_SUBNET_2"
          echo "ECS_SECURITY_GROUP: $ECS_SECURITY_GROUP"
          exit 1
        fi
        
        echo "âœ… CloudFormationì—ì„œ ë¦¬ì†ŒìŠ¤ ID ì¡°íšŒ ì™„ë£Œ!"
        
        # ECS ì„œë¹„ìŠ¤ ìƒì„±
        aws ecs create-service \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service-name ${{ env.ECS_SERVICE }} \
          --task-definition ${{ env.CONTAINER_NAME }} \
          --desired-count 1 \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[$PUBLIC_SUBNET_1,$PUBLIC_SUBNET_2],securityGroups=[$ECS_SECURITY_GROUP],assignPublicIp=ENABLED}" \
          --enable-execute-command \
          --tags "key=Environment,value=${{ env.ENVIRONMENT }}" "key=Project,value=wherewego"

    - name: Update existing ECS service
      if: steps.check-service.outputs.service_exists == 'true'
      run: |
        echo "Updating existing ECS service with new task definition..."
        
        # ECS ì„œë¹„ìŠ¤ ì—…ë°ì´íŠ¸
        aws ecs update-service \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service ${{ env.ECS_SERVICE }} \
          --task-definition ${{ env.CONTAINER_NAME }} \
          --desired-count 1
        
        echo "âœ… ECS service updated successfully!"
        
        # ì„œë¹„ìŠ¤ ì•ˆì •í™” ëŒ€ê¸°
        echo "Waiting for service stability..."
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }}
        
        echo "âœ… Service is now stable!"

    - name: Run task directly and check logs
      run: |
        echo "ğŸš€ Running ECS task directly for debugging..."
        
        # íƒœìŠ¤í¬ë¥¼ ì§ì ‘ ì‹¤í–‰
        echo "Starting new task..."
        TASK_ARN=$(aws ecs run-task \
          --cluster ${{ env.ECS_CLUSTER }} \
          --task-definition ${{ env.CONTAINER_NAME }} \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[$PUBLIC_SUBNET_1,$PUBLIC_SUBNET_2],securityGroups=[$ECS_SECURITY_GROUP],assignPublicIp=ENABLED}" \
          --query 'tasks[0].taskArn' \
          --output text)
        
        echo "Task started: $TASK_ARN"
        
        # íƒœìŠ¤í¬ ìƒíƒœ ëª¨ë‹ˆí„°ë§
        echo "Waiting for task to start..."
        sleep 30
        
        # íƒœìŠ¤í¬ ìƒíƒœ í™•ì¸
        TASK_STATUS=$(aws ecs describe-tasks \
          --cluster ${{ env.ECS_CLUSTER }} \
          --tasks $TASK_ARN \
          --query 'tasks[0].lastStatus' \
          --output text)
          
        echo "Task Status: $TASK_STATUS"
        
        # íƒœìŠ¤í¬ ìƒì„¸ ì •ë³´ ì¶œë ¥
        echo "ğŸ“‹ Task Details:"
        aws ecs describe-tasks \
          --cluster ${{ env.ECS_CLUSTER }} \
          --tasks $TASK_ARN \
          --query 'tasks[0].{TaskArn:taskArn,LastStatus:lastStatus,DesiredStatus:desiredStatus,StoppedReason:stoppedReason,Containers:containers[*].{Name:name,LastStatus:lastStatus,ExitCode:exitCode,Reason:reason}}' \
          --output table
        
        # ì»¨í…Œì´ë„ˆë³„ ë¡œê·¸ í™•ì¸
        echo "ğŸ“„ Checking container logs..."
        
        # Redis ë¡œê·¸
        echo "=== Redis Container Logs ==="
        aws logs get-log-events \
          --log-group-name "/ecs/wherewego-redis" \
          --log-stream-name "ecs/redis/$(echo $TASK_ARN | cut -d'/' -f3)" \
          --query 'events[*].message' \
          --output text || echo "No Redis logs found yet"
        
        # Spring Boot ì•± ë¡œê·¸
        echo "=== Spring Boot App Logs ==="
        aws logs get-log-events \
          --log-group-name "/ecs/wherewego-app" \
          --log-stream-name "ecs/wherewego-app/$(echo $TASK_ARN | cut -d'/' -f3)" \
          --query 'events[*].message' \
          --output text || echo "No app logs found yet"
        
        # 30ì´ˆ ë” ê¸°ë‹¤ë¦° í›„ ë‹¤ì‹œ í™•ì¸
        echo "Waiting 30 more seconds and checking again..."
        sleep 30
        
        # ìµœì¢… íƒœìŠ¤í¬ ìƒíƒœ í™•ì¸
        FINAL_STATUS=$(aws ecs describe-tasks \
          --cluster ${{ env.ECS_CLUSTER }} \
          --tasks $TASK_ARN \
          --query 'tasks[0].lastStatus' \
          --output text)
          
        echo "Final Task Status: $FINAL_STATUS"
        
        if [[ "$FINAL_STATUS" == "RUNNING" ]]; then
          echo "âœ… Task is running successfully!"
          
          # íƒœìŠ¤í¬ ì •ë¦¬ (í…ŒìŠ¤íŠ¸ìš©ì´ë¯€ë¡œ)
          echo "Stopping test task..."
          aws ecs stop-task \
            --cluster ${{ env.ECS_CLUSTER }} \
            --task $TASK_ARN \
            --reason "Test deployment completed"
        else
          echo "âŒ Task failed to start or stopped unexpectedly"
          
          # ì‹¤íŒ¨ ì›ì¸ ìƒì„¸ ì¡°íšŒ
          echo "=== Failure Analysis ==="
          aws ecs describe-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --tasks $TASK_ARN \
            --query 'tasks[0]' \
            --output json
        fi

  notify:
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: always()
    
    steps:
    - name: Notify deployment result
      if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' || github.ref == 'refs/heads/feature/docker-deployment'
      run: |
        if [[ "${{ needs.build-and-deploy.result }}" == "success" ]]; then
          echo "âœ… ë°°í¬ê°€ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!"
        else
          echo "âŒ ë°°í¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
        fi